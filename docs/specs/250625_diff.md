## 変更の方向性・目的

•	翻訳後の日本語テキスト（原文ではなく翻訳結果）を対象に、LLMが品質向上のための修正提案を行う。
•	長文の場合、翻訳後のテキストを段落やセクション単位に分割してLLMに渡す。文脈を保った小分け処理で処理効率と修正品質のバランスを両立し、段落単位の一貫性も維持できる。
•	修正提案は変更点のみを示す差分形式で出力させ、統合差分形式（Unified Diff）を採用する。この形式はGitパッチ互換の行単位差分で、既存ツールで適用可能かつ人間にも読解しやすい。
•	LLMには差分のみを厳密な書式で出力するよう指示し、安定した修正提案を得る。出力されたUnified DiffはPythonのpatch-ngライブラリで自動適用され、LLMは提案に専念し、実際のテキスト更新はスクリプトが担う。
•	再試行時は修正後テキストを output_fixed_1.txt 等の別ファイルに保存し、変更履歴を残す。ファイル名に試行番号や日時を含めて管理することで、各段階の比較検証や巻き戻しを容易にする。

# DiffProcessorとMarkdown処理の仕様書（変更後の結果）

## 概要
DiffProcessorは翻訳後の日本語テキストに対して品質向上のための修正提案を行うシステムです。Markdown文書の場合は、見出し・表・画像などの重要な構造要素を保護しながら処理を行います。

## 現在の処理フロー

### 1. 入力テキストの判定
- `is_markdown_file()` でMarkdown形式かどうかを判定
- Markdownパターン（見出し、画像、表、リンク、強調など）を検出

### 2. 重要なMarkdown要素の保護（Critical Protection）
```python
# 見出し・表・画像を絶対保護
text, critical_blocks = extract_critical_markdown_blocks(text)
```

#### 保護対象（優先度順）
1. **画像** (`![](...)`) → `__CRITICAL_IMAGE_N__`
2. **表** (`|...|` の複数行) → `__CRITICAL_TABLE_N__`
3. **見出し** (`# ## ###` など) → `__CRITICAL_HEADER_N__`

### 3. 通常のMarkdown要素の保護（Standard Protection）
```python
# その他のMarkdown要素も保護
text, markdown_blocks = extract_markdown_blocks(text)
```

#### 保護対象
- コードブロック (`__MARKDOWN_CODE_BLOCK_N__`)
- リンク (`__MARKDOWN_LINK_N__`)
- 太字 (`__MARKDOWN_BOLD_N__`)
- 斜体 (`__MARKDOWN_ITALIC_N__`)
- インラインコード (`__MARKDOWN_INLINE_CODE_N__`)
- リスト (`__MARKDOWN_LIST_ITEM_N__`)
- 順序付きリスト (`__MARKDOWN_ORDERED_LIST_N__`)
- 引用 (`__MARKDOWN_BLOCKQUOTE_N__`)

### 4. チャンク分割
- 長文の場合は段落・セクション単位で分割
- Markdownブロックの境界を保持

### 5. LLM処理
#### DiffProcessorの場合
- 品質閾値（デフォルト0.95）を下回る場合に実行
- 改善提案をUnified Diff形式で出力するよう指示
- プレースホルダーの削除を禁止するよう強調

#### Translatorの場合
- 翻訳処理を実行
- プレースホルダーの削除を禁止するよう強調

### 6. 復元処理
```python
# 重要なMarkdown要素を復元
if critical_blocks:
    improved_text = restore_critical_markdown_blocks(improved_text, critical_blocks)
```

## 現在の問題点

### 1. LLMの混乱
- **問題**: プロンプトの指示文がそのまま出力に含まれる
- **原因**: LLMが「改善されたテキストのみを返してください」の指示を無視
- **影響**: 最終出力に不要な指示文が混入

### 2. Diff形式の不整合
- **問題**: LLMがUnified Diff形式ではなく、改善されたテキストを直接出力
- **原因**: Diff形式の出力指示がLLMに正しく理解されていない
- **影響**: 差分の追跡が困難、修正履歴が不明

### 3. 方法論の根本的問題
- **問題**: LLMに「差分のみ出力」と「テキスト改善」の両方を求める矛盾
- **原因**: 自然言語生成モデルは差分形式の出力に不向き
- **影響**: 安定した修正提案が得られない

## 技術的制約

### LLMの特性
- 自然言語生成が主目的
- 構造化された出力（差分形式）は苦手
- プロンプトの指示文を翻訳・改善してしまう傾向

### プレースホルダー保護の限界
- プレースホルダーが多すぎるとLLMが混乱
- 重要な要素とそうでない要素の区別が困難
- 復元処理の複雑性が増加

## 改善提案

### 短期的改善
1. **プロンプトの簡素化**: 指示文を最小限に抑制
2. **出力形式の統一**: 差分形式か改善テキストか、どちらかに統一
3. **プレースホルダーの削減**: 最重要要素のみに限定

### 長期的改善
1. **アーキテクチャの見直し**: LLMの特性に合わせた設計
2. **段階的処理**: 保護→処理→復元を明確に分離
3. **代替手法の検討**: 差分ベース以外の品質改善手法

## 現在の実装状況

### 成功している部分
- ✅ 見出し・表・画像の保護・復元
- ✅ Markdown構造の基本的な保持
- ✅ 翻訳品質の向上

### 改善が必要な部分
- ❌ LLM出力の制御
- ❌ 差分形式の安定性
- ❌ プロンプトの効果
- ❌ 処理履歴の追跡

## 結論

現在の方法論は概念的に正しいが、LLMの特性との不整合により実用的な制約があります。特に「差分形式での出力」と「自然言語生成」の矛盾が根本的な問題となっています。短期的には出力形式の統一、長期的にはアーキテクチャの見直しが必要です。

## 上記を踏まえた新しい方針

手順は①構造保護 → ②翻訳 → ③復元の三段階。
	1.	前処理
Markdown構造を検出しテキスト以外をプレースホルダー化。例：画像 ![](pic.jpg) → __CRITICAL_IMAGE_1__、表ブロック → __CRITICAL_TABLE_1__、見出し # タイトル → __CRITICAL_HEADER_1__、リンク [anchor](url) → __MARKDOWN_LINK_1__。必要最小限に留め、強調やリストは原則そのまま残す。
	2.	翻訳
GPT-4.1-mini へ「Markdown記法とプレースホルダーを絶対に変更せず、自然言語部分のみ最小限に翻訳せよ」と命令。段落やセクション単位でチャンク化して送り、コードブロックや改行も保持させる。
	3.	復元・検証
出力から対応表でプレースホルダーを元の構造に戻し、チャンクを結合。仕上げに元Markdownと自動比較し、![]()、|、[link](…) 等の構造要素が一致するか確認する。

この方式はLLMに「翻訳」だけを任せ、構造維持は前後処理で担保するため、超長文でも高速・低コストかつ高い構造保持率を実現できる。